
# JSON Web Token II

# Introduction

This course details the exploitation of a weakness in JSON Web Token (JWT). In this application, JWT is used for authentication. Upon successful login, the user is issued a JWT in a cookie.

* If you want to do it by yourself, you can follow the following steps:

    * Inspect the token you receive when you visit the site.

    * Tamper with the token to gain admin access.

## The vulnerability

* This issue was originally discussed in the following blog post: https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/

* In this article, Tim McLean discussed multiple issues in the signature mechanism used by JWT. In this exercise, we are going to focus on the first issue.

* Multiple signature methods can be used to ensure the integrity of JWT:

    * RSA based
    * Elliptic curves
    * HMAC
    * None

* Here, the application uses `RSA`. You can even download the public key if you want to be able to verify the token. Since you don't have the private key, you cannot generate a valid token (in theory). In a real scenario, you may get to get the public key from a JavaScript script or from a mobile application.

* With RSA, to:

    * sign a token, you need the private key.

    * verify a token, you can use the public key corresponding to the private key used for the signature.

* With HMAC, to:

	* sign a token, you need the secret.

	* verify a token, you need the same secret.

* In practice, you can change the algorithm used by the application (`RSA - RS256`) to tell it to use `HMAC` (`HS256`). 

* The application will call the method verify when you send the cookie. Since the code is written to use `RSA`, it will call `verify(public_key, data)`. But since the algorithm is set to `HMAC`, it will end up calling `HMAC(public_key,data)`.

* The application will verify the signature with the public key but since you are forcing the application to use `HMAC`, it will actually verify the signature with `HMAC(public_key, data)`. As an attacker, you have everything you need to generate a valid signature, since the public key is actually public.

## Exploitation

* To exploit this vulnerability, you just need to decode the JWT and change the algorithm used for the signature. Change the username to `admin`. Then you can compute the new signature and submit your new JWT.

* To create the correct signature, you need to look at the details of the JWT format to understand what data is signed and how it's signed. The JWT format sign the base64-URL encoded without padding ( https://tools.ietf.org/html/rfc7515#appendix-C ) header and the base64-URL encoded without padding data after concatenating them with a single dot `.`.

## Conclusion

* This exercise showed you how you can tamper with a JWT to gain administrator access in the application. It showed you that having a signed value is only as strong as the weakest algorithm used if an attacker can pick what algorithm is used.


* You can access this exercise using the following URL: http://ptl-1ff0ba3b-3222b644.libcurl.so/

* In `/public.pem` you will find the public key download it and you need not change anything it the `public.pem`.

* After running `solver.py` you will get the new cookie of `admin` and you submit that cookie to get the key.
